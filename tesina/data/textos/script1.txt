<!DOCTYPE html>
<html lang="es" dir="ltr">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>
      Tes-aenz o Saenz-ina
    </title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: rgb(1, 1, 1);
        font-family: 'Source Code Pro', monospace;
        text-align: center;
        overflow: hidden;
      }
      p {
        color: #FAFAFA;
        background-color: Transparent;
        position: absolute;
        text-align: left;
      }
      input {
        color: #FAFAFA;
        position: absolute;
        font-family: 'Source Code Pro', monospace;
        background-color: Transparent;
      }
      #bContinuar {
        top: 85%;
        left: 80%;
        font-size: 30px;
        background-repeat: no-repeat;
        border: none;
      }
      #dato {
        text-align: left;
        opacity: 1;
        color: #FAFAFA;
        top: 35%;
        left: 80%;
      }
      #nombre {
        top: 80%;
        left: 40%;
        font-size: 24px;
        text-align: "center";
      }

      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
      }
      #instructions {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 14px;
        cursor: pointer;
        position: absolute;
      }
    </style>

  </head>

  <body>
    <div id="blocker">
      <div id="instructions">
        <p id= "tins" style="font-size:24px">
        </p>
        <p id= "play" style="font-size:24px">
          <br/><br/><br/><br/><br/> Hace click para empezar
        </p>
      </div>
    </div>

    <script id="codigo" type="module" src="./script1.js"></script>
    <!-- <input id="nombre" type="text" placeholder="Nombre"/> -->
    <input id="bContinuar" type="button" value=""/>
  </body>

</html>

///////////////////////////// FIGURA //////////////////////////////////

import {
  crearInstanciaB
} from '../Funciones/modelos3D.js'
import {
  scale
} from '../Funciones/calculos.js'

export class Figura {
  constructor(id = -1, forma = 'cubo', color = '#FF0000', x = 0, z = 0, nombre = "juph", sonido = '../data/sonidos/1/Sonido (1).wav', activo = false) {
    this.nombre = nombre;
    this.id = id;
    this.forma = forma;
    this.color = color;
    this.x = x;
    this.y = 0.1;
    this.z = z;
    this.pos = -1 //posicion en el arreglo de modelos
    ///// estos porahora no importan
    this.sonido = sonido;
    this.activo = activo;
    this.radio = 9;
    this.conexiones = [];
    this.tiempo = 0;
  }
  crearID() {
    //crea una ID unica de usuario usando el nombre + numeros random
    if (this.id != -1) {
      this.id = id;
    }
    const n = parseInt(Math.random() * 999);
    this.id = this.nombre.concat("-", n.toString());
  }
  _distancia(x, y, z) {
    //calculo de distancia entre una figura y el usuario
    var a = this.x - x;
    var b = this.y - y;
    var c = this.z - z;

    var distance = a * a + b * b + c * c;
    if (distance < Math.pow(this.radio, 2)) {
      return true;
    }
    return false;
  }
  calcularConexiones(figuras, todas = false) {
    //Calcular la distancia de todas las figuras y guardar las que esten dentro de la distancia determinada
    for (var i = 0; i < figuras.length; i++) {
      if (this._distancia(figuras[i].x, figuras[i].y, figuras[i].z)) {
        var found = this.conexiones.findIndex(f => f.id === figuras[i].id);
        if (found === -1) {
          if (todas || figuras[i].pos != -1) {
            //Si veo todas las formas o si veo solo las formas parecidas
            this.conexiones.push(figuras[i]);
          }
        }
      } else {
        var found = this.conexiones.findIndex(f => f.id === figuras[i].id);
        if (found != -1) {
          this.conexiones.splice(found, 1);
        }
      }

    }
    //console.log("conexiones usuario: ",this.conexiones.length);
  }
  ecuacionDeUsuarioA(otro) {
    var m = 0;
    var t = "";
    if (this.forma == otro.forma) {
      m += 5;
      t = t.concat("forma, ");
    }
    if (this.color == otro.color) {
      m += 2;
      t = t.concat("color, ");
    }
    if (this.activo == otro.activo) {
      m += 0.5;
      t = t.concat("activo, ");
    }
    //console.log("hewo",this.sonido[16],"-",otro.sonido[15])
    if (this.sonido[16] == otro.sonido[15]) {
      m += 2;
      t = t.concat("sonido, ");
    }
    if (this.conexiones.length == otro.conexiones.length) {
      m += 0.5;
      t = t.concat("length");
    }
    const res = scale(m, 0, 10, 0, 1);
    //console.log(t,res);
    return res;
  }
  texto(reloj, orientacion = "estático", similitud = -1) {
    const t = "Usuario: ".concat(this.nombre, "\n");
    const t2 = "ID: ".concat(this.id, "\n");
    const t3 = "Forma: ".concat(this.forma, "\n");
    let t4;
    if (this.color.length == 7) {
      t4 = "Color: ".concat(this.color, "\n");
    } else {
      t4 = "Color: ".concat("#",this.color.getHexString().toUpperCase(), "\n");
    }
    const t5 = "Posición: ".concat(parseInt(this.x), ", ", parseInt(this.y), ", ", parseInt(this.z), "\n");
    const t9 = "Rotación: ".concat(orientacion, "\n");
    const t6 = "Sonido: ".concat(this.sonido, "\n");
    const t7 = "Formas cerca: ".concat(this.conexiones.length, "\n");
    const t8 = "Tiempo: ".concat(parseInt(this.tiempo + reloj), "\n");
    let t10 = "";
    if (similitud != -1){
      t10 = "Similitud con usuario: ".concat(similitud*100,"%\n");
    }
    const tFinal = t.concat(t2, t3, t4, t5, t9, t6, t7, t8,t10);
    //console.log(tFinal)
    return tFinal;
  }
  limite(lim) {
    if (this.x > lim) {
      this.x = -lim + 5;
      return true;
    } else if (this.x < -lim) {
      this.x = lim - 5;
      return true;
    }
    if (this.z > lim) {
      this.z = -lim + 5;
      return true;
    } else if (this.z < -lim) {
      this.z = lim - 5;
      return true;
    }
    return false;
  }
}

//////////////////////// MUNDO ///////////////////////////////////////

import {
  crearInstanciaB
} from '../Funciones/modelos3D.js'
import {
  scale
} from '../Funciones/calculos.js'

export class Figura {
  constructor(id = -1, forma = 'cubo', color = '#FF0000', x = 0, z = 0, nombre = "juph", sonido = '../data/sonidos/1/Sonido (1).wav', activo = false) {
    this.nombre = nombre;
    this.id = id;
    this.forma = forma;
    this.color = color;
    this.x = x;
    this.y = 0.1;
    this.z = z;
    this.pos = -1 //posicion en el arreglo de modelos
    ///// estos porahora no importan
    this.sonido = sonido;
    this.activo = activo;
    this.radio = 9;
    this.conexiones = [];
    this.tiempo = 0;
  }
  crearID() {
    //crea una ID unica de usuario usando el nombre + numeros random
    if (this.id != -1) {
      this.id = id;
    }
    const n = parseInt(Math.random() * 999);
    this.id = this.nombre.concat("-", n.toString());
  }
  _distancia(x, y, z) {
    //calculo de distancia entre una figura y el usuario
    var a = this.x - x;
    var b = this.y - y;
    var c = this.z - z;

    var distance = a * a + b * b + c * c;
    if (distance < Math.pow(this.radio, 2)) {
      return true;
    }
    return false;
  }
  calcularConexiones(figuras, todas = false) {
    //Calcular la distancia de todas las figuras y guardar las que esten dentro de la distancia determinada
    for (var i = 0; i < figuras.length; i++) {
      if (this._distancia(figuras[i].x, figuras[i].y, figuras[i].z)) {
        var found = this.conexiones.findIndex(f => f.id === figuras[i].id);
        if (found === -1) {
          if (todas || figuras[i].pos != -1) {
            //Si veo todas las formas o si veo solo las formas parecidas
            this.conexiones.push(figuras[i]);
          }
        }
      } else {
        var found = this.conexiones.findIndex(f => f.id === figuras[i].id);
        if (found != -1) {
          this.conexiones.splice(found, 1);
        }
      }

    }
    //console.log("conexiones usuario: ",this.conexiones.length);
  }
  ecuacionDeUsuarioA(otro) {
    var m = 0;
    var t = "";
    if (this.forma == otro.forma) {
      m += 5;
      t = t.concat("forma, ");
    }
    if (this.color == otro.color) {
      m += 2;
      t = t.concat("color, ");
    }
    if (this.activo == otro.activo) {
      m += 0.5;
      t = t.concat("activo, ");
    }
    //console.log("hewo",this.sonido[16],"-",otro.sonido[15])
    if (this.sonido[16] == otro.sonido[15]) {
      m += 2;
      t = t.concat("sonido, ");
    }
    if (this.conexiones.length == otro.conexiones.length) {
      m += 0.5;
      t = t.concat("length");
    }
    const res = scale(m, 0, 10, 0, 1);
    //console.log(t,res);
    return res;
  }
  texto(reloj, orientacion = "estático", similitud = -1) {
    const t = "Usuario: ".concat(this.nombre, "\n");
    const t2 = "ID: ".concat(this.id, "\n");
    const t3 = "Forma: ".concat(this.forma, "\n");
    let t4;
    if (this.color.length == 7) {
      t4 = "Color: ".concat(this.color, "\n");
    } else {
      t4 = "Color: ".concat("#",this.color.getHexString().toUpperCase(), "\n");
    }
    const t5 = "Posición: ".concat(parseInt(this.x), ", ", parseInt(this.y), ", ", parseInt(this.z), "\n");
    const t9 = "Rotación: ".concat(orientacion, "\n");
    const t6 = "Sonido: ".concat(this.sonido, "\n");
    const t7 = "Formas cerca: ".concat(this.conexiones.length, "\n");
    const t8 = "Tiempo: ".concat(parseInt(this.tiempo + reloj), "\n");
    let t10 = "";
    if (similitud != -1){
      t10 = "Similitud con usuario: ".concat(similitud*100,"%\n");
    }
    const tFinal = t.concat(t2, t3, t4, t5, t9, t6, t7, t8,t10);
    //console.log(tFinal)
    return tFinal;
  }
  limite(lim) {
    if (this.x > lim) {
      this.x = -lim + 5;
      return true;
    } else if (this.x < -lim) {
      this.x = lim - 5;
      return true;
    }
    if (this.z > lim) {
      this.z = -lim + 5;
      return true;
    } else if (this.z < -lim) {
      this.z = lim - 5;
      return true;
    }
    return false;
  }
}

///////////////////////////// CUSTOMIZACIÓN /////////////////////////

import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js'; //'../threegit/build/three.module.js';;//'https://unpkg.com/three@0.118.3/build/three.module.js';//'../threeLibs/build/three.module.js';
import {
  crearInstancia,
  cargarSonido,
  eliminarSonido
} from './modelos3D.js'
import {
  elegirSonidoAzar
} from './calculos.js'
import {
  customizaciónA,
  customizaciónB,
  etapa1
} from '../script1.js'

var colores = {
  rosa: "#EC90BF",
  rosita: "#F15733",
  fucsia: "#FC3DC9",
  naranja: "#FDA449",
  anaranjado: "#F2B361",
  amarillo: "#E4BE5B",
  verde: "#7DFF9B",
  celeste: "#00FFF9",
  cian: "#39C7CB",
  azul: "#016DF6",
  violeta: "#9F34D8",
  lila: "#C86DDE"
}
var sonidos = [];

////////////////////////////////// Iniciar Customización ///////////////////////////////////

export function aviso() {
  // Aca deberia haber algun texto o algo
  //alert("aviso")
}

export function customizaciónAA(estado, escena) {
  // Hacer cutom
  estado = "customizaciónA";

  // Elimino si habia otras
  if (escena.children.length > 1) {
    if (escena.children[1].children.length > 1) {
      escena.children[1].children[1].stop();
      escena.children[1].remove(mundo.escena.children[1].children[1])
    }
    escena.remove(escena.children[1]);
    escena.remove(escena.children[1]);
  }

  crearFormasInicio(escena);
} // No funciona

function customizaciónBB(seleccion, lista, usuario, escena, listener, estado) {
  estado = "customizaciónB";

  // Guardo forma elegida
  if (seleccion.position.x < 0) {
    usuario.forma = "cubo";
  } else {
    usuario.forma = "cono";
  }

  // Eliminar objetos 3D no deseados
  for (var i = 1; i < lista.length; i++) {
    if (lista[i] != seleccion) {
      escena.remove(lista[i]);
    }
  }

  // Cambiar visualización
  seleccion.position.x = 0;
  seleccion.scale.set(1.5, 1.5, 1.5);

  // Botones
  escena.add(crearBotones(listener));
} // no funciona

////////////////////////////////// Interacción Customización ///////////////////////////////

export function tecladoCustomizacionB(texto) {
  var inp = String.fromCharCode(event.keyCode);
  if (/[a-zA-Z0-9-_]/.test(inp) && texto.length < 18) {
    if (texto == "escriba su nombre") {
      return inp.toLowerCase();
    } else {
      return texto + inp.toLowerCase();
    }
  } else if (event.key == 'Backspace'){
    return texto.slice(0, -1)
  }
  return texto;
}

export function clickCustomizacionA(lista, raycaster_, usuario, listener, escena, estado) {
  var intersects = raycaster_.intersectObjects(lista);
  if (intersects.length > 0) {
    const int = intersects[0].object;
    customizaciónB(int);
    //customizaciónBB(int, lista, usuario, escena, listener, estado);
  }
}

export function clickCustomizacionB(lista, raycaster_, usuario_, listener) {
  var botones = lista[2].children
  var intersects = raycaster_.intersectObjects(botones);
  if (intersects.length > 0) {
    const int = intersects[0].object;
    const index = botones.indexOf(int);
    if (index < Object.keys(colores).length) {
      // Toque botón color
      lista[1].material.color.set(int.material.color);
      usuario_.color = int.material.color;
    } else if (index == botones.length - 1) {
      // Toque botón volver
      customizaciónA();
    } else {
      /// elegir sonido
      console.log("click")
      for (var i = Object.keys(colores).length; i < botones.length - 1; i++) {
        botones[i].material.color.set(0x555555)
      }
      int.material.color.set(0xFAFAFA)
      if (lista[1].children.length > 1) {
        lista[1].children[1].stop();
        lista[1].remove(lista[1].children[1])
      }
      const pos = index - Object.keys(colores).length;
      const sonido = cargarSonido(listener, sonidos[pos], null);
      usuario_.sonido = sonidos[pos];
      lista[1].add(sonido);

    }
  }
}

////////////////////////////////// Funciones de Customización //////////////////////////////

export function crearFormasInicio(escena) {
  /// Crea las dos formas que se ven en customización A
  const cubo = crearInstancia('cubo', "#FFFFFF", -3, 0.5, -4);
  escena.add(cubo[0]);
  cubo[1].position.set(0, 0, 0);
  cubo[0].add(cubo[1]);

  const cono = crearInstancia('cono', "#FFFFFF", 3, 0.5, -4);
  escena.add(cono[0]);
  cono[1].position.set(0, 0.2, 0);
  cono[0].add(cono[1]);
}

export function rotarObjeto3D(obj) {
  obj.rotation.x -= 0.005;
  obj.rotation.y -= 0.01;
}

export function crearBotones(listener) {
  var botones = new THREE.Object3D;
  botonesColor(colores, botones);
  botonesSonido(listener, botones);
  botonVolver(botones);
  //botonContinuar(botones)
  return botones;
}

function botonesColor(colores, botones) {
  var i = 0;
  const geometry = new THREE.PlaneGeometry(0.06, 0.18);
  for (const key in colores) {
    const material = new THREE.MeshBasicMaterial({
      color: colores[key]
    });
    const circle = new THREE.Mesh(geometry, material);
    circle.position.set(-1.8, 1 - i * 0.18, 0);
    i++;
    botones.add(circle);
  }
}

function botonesSonido(listener, botones) {
  for (var i = 0; i < 5; i++) {
    const geometry = new THREE.CircleGeometry(0.04, 32);
    const material = new THREE.MeshBasicMaterial({
      color: 0xAAAAAA
    });
    const circle = new THREE.Mesh(geometry, material);
    circle.position.set(1.8, 0.5 - i * 0.22, 0);

    botones.add(circle);
    sonidos[i] = elegirSonidoAzar(i + 1);
  }
}

function botonVolver(botones) {
  /* FLECHA
  const material = new THREE.LineBasicMaterial({
    color: 0xFAFAFA,
  });
  const boton = new THREE.Line(_geometria(), material);
  boton.position.set(-2.3, 0.95, 0);
  */

  const geometry = new THREE.PlaneGeometry(0.12, 0.12);
  const material = new THREE.MeshBasicMaterial({
    color: 0x040404
  });
  const boton = new THREE.Mesh(geometry, material);
  boton.position.set(-2.18, 0.9, 0);

  botones.add(boton);
}

function _geometria() {
  const vertices = new Float32Array([
    0.09, 0.05, 0,
    0, 0, 0,
    0.09, -0.05, 0,
    0, 0, 0,
    0.2, 0, 0,
  ]);

  const geoCono = new THREE.BufferGeometry();
  geoCono.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

  return geoCono;
}

function botonContinuar(botones) {
  const geometry = new THREE.PlaneGeometry(1, 0.2);
  const material = new THREE.MeshBasicMaterial({
    color: 0x040404
  });
  const boton = new THREE.Mesh(geometry, material);
  boton.position.set(0, -0.7, 0);

  botones.add(boton);

  //////////////////////
}

////////////////////////////////// MODELOS 3D ////////////////////////////

import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js'; //'../threegit/build/three.module.js';;//'https://unpkg.com/three@0.118.3/build/three.module.js';//'../threeLibs/build/three.module.js';
import {
  BufferGeometryUtils
} from 'https://unpkg.com/three@0.121.1/examples/jsm/utils/BufferGeometryUtils.js'
import {
  Figura
} from '../Clases/Figura.js'

////
import {
  elegirSonidoAzar,
  colorRandom,
  booleanRandom,
  scale,
  colorOscuro
} from './calculos.js'


// Crea objetos con líneas
function _geometriaCubo() {
  const geo = new THREE.BufferGeometry();
  const vertices = new Float32Array([
    -1.0, 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, 1.0 - 0.66, 1.0,
    -1.0, 1.0 - 0.66, 1.0,
    -1.0, 1.0 - (0.66 * 2), 1.0,
    1.0, 1.0 - (0.66 * 2), 1.0,
    1.0, -1.0, 1.0,
    -1.0, -1.0, 1.0,
    -1.0, 1.0, 1.0,
    -1.0 + 0.66, 1.0, 1.0,
    -1.0 + 0.66, -1.0, 1.0,
    -1.0 + (0.66 * 2), -1.0, 1.0,
    -1.0 + (0.66 * 2), 1.0, 1.0,
    1.0, 1.0, 1.0,
    1.0, -1.0, 1.0,
    1.0, -1.0, -1.0,
    1.0, 1.0, -1.0,
    -1.0 + (0.66 * 2), 1.0, -1.0,
    -1.0 + (0.66 * 2), -1.0, -1.0,
    -1.0 + 0.66, -1.0, -1.0,
    -1.0 + 0.66, 1.0, -1.0,
    -1.0, 1.0, -1.0,
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0,
    1.0, 1.0 - (0.66 * 2), -1.0,
    -1.0, 1.0 - (0.66 * 2), -1.0,
    -1.0, 1.0 - 0.66, -1.0,
    1.0, 1.0 - 0.66, -1.0,
    1.0, 1.0, -1.0,
    -1.0, 1.0, -1.0,
  ]);

  geo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  const geo2 = new THREE.BufferGeometry();
  geo2.copy(geo);
  const geo3 = new THREE.BufferGeometry();
  geo3.copy(geo2);
  geo2.rotateY(-Math.PI * 0.5);
  geo3.rotateX(-Math.PI * 0.5);
  return BufferGeometryUtils.mergeBufferGeometries([geo, geo2, geo3]);
}

function _geometriaCono() {
  const vertices = new Float32Array([
    0, 1.5, 0,
    -0.5, -1, 1.2, //izq
    0.5, -1, 1.2, //derecha
    0, 1.5, 0, //arriba
    //1 triangulo
    -0.5, -1, -1.2, //izq
    0.5, -1, -1.2, // derecha
    0, 1.5, 0, //ariba
  ]);

  const geoCono = new THREE.BufferGeometry();
  geoCono.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

  const geoCono2 = new THREE.BufferGeometry();
  geoCono2.copy(geoCono)
  geoCono2.rotateY(-Math.PI * 0.5)

  const geoCono3 = new THREE.BufferGeometry();
  geoCono3.copy(geoCono2)
  geoCono3.rotateY(-Math.PI * 0.25)

  const geoCono4 = new THREE.BufferGeometry();
  geoCono4.copy(geoCono2)
  geoCono4.rotateY(Math.PI * 0.25)

  const geoFinalCono = BufferGeometryUtils.mergeBufferGeometries([geoCono, geoCono2, geoCono3, geoCono4]);
  return geoFinalCono;
}

// Crea un objeto3D líneas y uno sólido negro
export function crearInstancia(forma, colorcito, x, y, z) {
  //Crea los objetos 3D
  var geometria;
  var geo;
  if (forma === "cubo") {
    geometria = _geometriaCubo();

    geo = new THREE.BoxGeometry(2 * 0.96, 2 * 0.96, 2 * 0.96);
  } else {
    geometria = _geometriaCono();
    geo = new THREE.ConeGeometry(1.2 * 0.99, 2.4 * 0.99, 8, 8);
  }

  const material = new THREE.LineBasicMaterial({
    color: colorcito,
    linewidth: 2,
    linecap: 'round', //ignored by WebGLRenderer
    linejoin: 'round' //ignored by WebGLRenderer
  });
  const mesh = new THREE.Line(geometria, material);
  mesh.position.x = x;
  mesh.position.y = y;
  mesh.position.z = z;

  const mat = new THREE.MeshStandardMaterial({
    color: 0x010101
  });
  const interior = new THREE.Mesh(geo, mat);
  interior.position.x = x;
  interior.position.y = y;
  interior.position.z = z;

  if (forma === 'cono') {
    interior.rotation.y = 1;
  }

  return [mesh, interior];
}

// Crea un objeto texto
export function crearTexto(escena, mensaje = "no hay mensaje", x = 0, y = 0, z = 0){
  //crear texto
  var text;
  const loader = new THREE.FontLoader();

  loader.load('../data/Fonts/Source Code Pro_Regular.json', function(font) {
    const matLite = new THREE.MeshBasicMaterial({
      color: 0xFAFAFA,
    });

    const shapes = font.generateShapes(mensaje, 0.1);
    const geometry = new THREE.ShapeGeometry(shapes);

    geometry.computeBoundingBox();
    const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
    geometry.translate(xMid, 0, 0);

    text = new THREE.Mesh(geometry, matLite);
    text.position.set(x,y,z)
    escena.add(text);

  });

}

// Crea un objeto sonido
export function cargarSonido(listener, archivo, fig) {
  const audioLoader = new THREE.AudioLoader();

  const sonido = new THREE.PositionalAudio(listener);
  audioLoader.load(archivo, function(buffer) {
    sonido.setBuffer(buffer);
    sonido.setRefDistance(0.7);

    var m = 1.5;
    /*if (fig != null && !fig.activo) {
      m = Math.random() * 1.5 + 0.8;
    }*/
    sonido.setRolloffFactor(m);
    sonido.setMaxDistance(1000);
    //entre 0.5 y 0.22
    sonido.setLoop(true);
    ////sonido.setVolume(4);
    sonido.setVolume(1);
    sonido.play();
    sonido.setDistanceModel("exponential");
  });

  return sonido;
}

export function eliminarSonido(lista){
  if (lista[1].children.length > 1) {
    lista[1].children[1].stop();
    lista[1].remove(lista[1].children[1])
  }
}

/////////////////////////////// Espacio 3D ////////////////////////////////////
export function crearFormaUsuario(escena, listener, usuario) {
  var modelo = [];
  modelo = crearInstancia(usuario.forma, usuario.color, usuario.x, usuario.y, usuario.z);
  escena.add(modelo[0]);
  modelo[0].add(modelo[1]);
  modelo[1].position.y = 0;
  modelo[0].add( cargarSonido(listener, usuario.sonido));

  modelo[0].geometry.computeBoundingBox();
  return modelo[0];
}

export function figurasAleatorias(red) {
  for (var i = 0; i < 30; i++) {
    var ran = Math.floor(Math.random() * (1 - 0 + 1) + 0);
    var tipo = 'cubo';
    if (ran >= 1) {
      tipo = 'cono';
    }
    var f = new Figura(-1, tipo, colorRandom(), 40 - Math.random() * 80, 40 - Math.random() * 80, "juph-prueba", elegirSonidoAzar(), booleanRandom());
    f.crearID();
    red.push(f);
  }
}

export function figuraPrueba(red) {
  var f;
  f = new Figura(-1, "cubo", 0x550000, 0, -10, "prueba", "../data/sonidosB/Sonido (6).wav", true);
  red.push(f);
}

export function agregarModelo(listener, f) {
  var m = crearInstancia(f.forma, f.color, f.x, f.y, f.z);
  m[1].position.set(0, 0, 0);
  m[0].add(m[1]);
  m[0].add(cargarSonido(listener, f.sonido, f));
  if (f.activo) {
    //m[1].material.color.set(m[0].material.color);
    m[1].material.color.set(colorOscuro(m[0].material.color));
  }

  m[0].geometry.computeBoundingBox();
  return m[0];
}

export function agregarModelos(listener, red, modelosRed, usuario, indicesSimilitud) {
  // Paso la red a modelos 3D
  indicesSimilitud.splice(0, indicesSimilitud.length)
  for (var i = 0; i < red.length; i++) {
    red[i].calcularConexiones(red);
    indicesSimilitud.push(usuario.ecuacionDeUsuarioA(red[i]));
    modelosRed.add(agregarModelo(listener, red[i]));
    red[i].pos = modelosRed.length-1;
  }
}

export function agregarModelosCurado(listener, red, modelosRed, indicesSimilitud, usuario) {
  console.log("eran: ", red.length);
  for (var i = 0; i < red.length; i++) {
    red[i].calcularConexiones(red);
    indicesSimilitud.push(usuario.ecuacionDeUsuarioA(red[i]));
    if (indicesSimilitud[i] >= 0.6 || red[i].activo) {
      modelosRed.add(agregarModelo(listener, red[i]));
      red[i].pos = modelosRed.children.length - 1;
    }
  }
  console.log("veo: ", modelosRed.children.length);
}

export function moveteSiNosParecemos(figuras, indice) {
  //calcula cuanto se va a mover la figura segun el indice de similitud
  for (var i = 0; i < figuras.length; i++) {
    //const j = Math.random() * 10;
    const m = scale(indice[i], 0, 1, 0, 0.008);
    figuras[i].rotation.y += m;
  }
}

export function posInicioUsuario(usuario, red, indicesSimilitud) {
  var max = -1;
  var maxPos = -1;
  for (var i = 0; i < red.length; i++) {
    if (indicesSimilitud[i] > max) {
      max = indicesSimilitud[i];
      maxPos = i;
    }
  }
  // encontre el más similar
  const k = Math.random() * 3.5 + 1;
  const j = Math.random() * 3.5 + 1;
  usuario.x = red[maxPos].x + k;
  usuario.z = red[maxPos].z + j;
}

////////// Para debuggeo

export function crearInstanciaB(forma, color, x, y, z) {
  //Crea objeto 3D
  const material = new THREE.MeshPhongMaterial({
    color
  });

  var geometria;
  if (forma == 'cubo') {
    geometria = new THREE.BoxGeometry(1, 1, 1); // Geometria 1
  } else {
    geometria = new THREE.ConeGeometry(0.7, 1, 12); // Geometria 2
  }

  const instancia = new THREE.Mesh(geometria, material);
  instancia.position.x = x;
  instancia.position.y = y;
  instancia.position.z = z;
  return instancia;
}

///////////////////////////////// ESPACIO 3D //////////////////////

import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js'; //'../threegit/build/three.module.js';;//'https://unpkg.com/three@0.118.3/build/three.module.js';//'../threeLibs/build/three.module.js';
import {
  agregarModelo,
  agregarModelos,
  agregarModelosCurado
} from './modelos3D.js'
import { scale } from './calculos.js'
////////////////////////////////// Interacción con click

export function clickEtapa3(lista, red_, raycaster_, mouse, indicesSimilitud) {
  var intersects = raycaster_.intersectObjects(lista);
  if (intersects.length > 0) {
    const int = intersects[0].object;
    const index = lista.indexOf(int);
    console.log(intersects);

    const posX = scale(mouse.x,-1,1,0,window.innerWidth) - 10;
    const posY = scale(-mouse.y,-1,1,0,window.innerHeight) - 10;

    console.log('mouse', posX, posY)
    const t = document.createElement('p');
    t.setAttribute('id','dato');
    t.style.left= posX.toString() + "px";
    t.style.top= posY.toString() + "px";
    t.style.opacity =1;
    t.innerText = red_[index].texto(0, "estático", indicesSimilitud[index]);
    document.body.append(t);

    return index;
  }
  return -1;

}

////////////////////////////////// Interacción Teclado

export function tecladoEtapa1(e, usuario) {
  switch (e.keyCode) {
    case 37:
    case 65:
      //derecha
      usuario.x -= 0.2;
      break;
    case 38:
    case 87:
      //arriba
      usuario.z -= 0.2;
      break;
    case 39:
    case 68:
      //izquierda
      usuario.x += 0.2;
      break;
    case 40:
    case 83:
      //abajo
      usuario.z += 0.2;
      break
  }
}

export function tecladoEtapa2(orientacion, e, usuario, colision, lastKey) {
  switch (e.keyCode) {
    //derecha
    case 37:
    case 65:
      if (e.keyCode != colision) {
        switch (orientacion) {
          case "frente":
            usuario.x -= 0.4;
            break;
          case "izquierda":
            usuario.z += 0.4;
            break;
          case "derecha":
            usuario.z -= 0.4;
            break;
          case "espalda":
            usuario.x += 0.4;
            break;
        }
      }
      break;
      //arriba
    case 38:
    case 87:
      if (e.keyCode != colision) {
        switch (orientacion) {
          case "frente":
            usuario.z -= 0.4;
            break;
          case "izquierda":
            usuario.x -= 0.4;
            break;
          case "derecha":
            usuario.x += 0.4;
            break;
          case "espalda":
            usuario.z += 0.4;
            break;
        }
      }
      break;
      //izquierda
    case 39:
    case 68:
      if (e.keyCode != colision) {
        switch (orientacion) {
          case "frente":
            usuario.x += 0.4;
            break;
          case "izquierda":
            usuario.z -= 0.4;
            break;
          case "derecha":
            usuario.z += 0.4;
            break;
          case "espalda":
            usuario.x -= 0.4;
            break;
        }
      }
      break;
      //abajo
    case 40:
    case 83:
      if (e.keyCode != colision) {
        switch (orientacion) {
          case "frente":
            usuario.z += 0.4;
            break;
          case "izquierda":
            usuario.x += 0.4;
            break;
          case "derecha":
            usuario.x -= 0.4;
            break;
          case "espalda":
            usuario.z -= 0.2;
            break;
        }
      }
      break;
  }
  lastKey = e.keyCode;
}

////////////////////////////////// Vistas
export function contemplacion(estado) {
  if (estado != "contemplacion") {
    estado = "contemplacion";
  } else {
    estado = "etapa1";
  }
  console.log(estado)
  return estado;
}

export function recargarVistaCurada(listener, red, modelos, indicesSimilitud, usuario) {
  console.log("Paso a vista curada")
  for (var i = 0; i < red.length; i++) {
    if (indicesSimilitud[i] <= 0.6) {
      red[i].pos = -1;
    }
  }
  while (modelos.children.length > 0) {
    modelos.children[modelos.children.length - 1].children[1].stop();
    modelos.remove(modelos.children[modelos.children.length - 1])
  }
  agregarModelosCurado(listener, red, modelos, indicesSimilitud, usuario);
}

export function vistaTotalModelos(listener, red, modelos, usuario, indicesSimilitud) {
  while (modelos.children.length > 0) {
    modelos.children[modelos.children.length - 1].children[1].stop();
    modelos.remove(modelos.children[modelos.children.length - 1])
  }
  agregarModelos(listener, red, modelos, usuario, indicesSimilitud);
}

////////////////////////////////////// CALCULOS ///////////////////////////////////

var colores = {
  rosa: "#EC90BF",
  rosita: "#F15733",
  fucsia: "#FC3DC9",
  naranja: "#FDA449",
  anaranjado: "#F2B361",
  amarillo: "#E4BE5B",
  verde: "#7DFF9B",
  celeste: "#00FFF9",
  cian: "#39C7CB",
  azul: "#016DF6",
  violeta: "#9F34D8",
  lila: "#C86DDE"
}

export function elegirSonidoAzar(carpeta = "1") {
  const n1 = parseInt(Math.random() * 6 + 1).toString();
  const n3 = "./data/sonidos/".concat(carpeta,"/Sonido (",n1,").wav")
  return n3;
}

export function colorRandom() {
  /*const n1 = parseInt(Math.random() * 200).toString(16);
  const n2 = parseInt(Math.random() * 200).toString(16);
  const n3 = parseInt(Math.random() * 200).toString(16);
  var c = "#".concat(n1, n2, n3);
  while (c.length < 7) {
    c = c.concat("0");
  }*/
  const m = parseInt(Math.random() * (Object.keys(colores).length - 1));
  return Object.values(colores)[m];
}

export function colorOscuro(color){
  var colorN = 0x010101;
  if (color.r > color.g && color.r > color.b){
    colorN = 0x050101;
  } else if (color.b > color.r && color.b > color.g){
    colorN = 0x020104;
  } else {
    colorN = 0x010301;
  }
  return colorN
}

export function booleanRandom(){
  const m = Math.random();
  if (m > 0.8){
    return true;
  } else {
    return false;
  }
}

export function scale(number, inMin, inMax, outMin, outMax) {
  return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}

///////////////////////////////////////// SCRIPT ///////////////////////////

import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js'; //'../threegit/build/three.module.js';;//'https://unpkg.com/three@0.118.3/build/three.module.js';//'../threeLibs/build/three.module.js';
import {
  PointerLockControls
} from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/PointerLockControls.js'
import {
  Mundo
} from './Clases/Mundo.js';
import {
  Figura
} from './Clases/Figura.js'
import {
  crearFormaUsuario,
  figurasAleatorias,
  figuraPrueba,
  agregarModelos,
  agregarModelosCurado,
  moveteSiNosParecemos,
  posInicioUsuario,
  crearTexto
} from './Funciones/modelos3D.js';
import {
  aviso,
  crearFormasInicio,
  crearBotones,
  clickCustomizacionA,
  clickCustomizacionB,
  tecladoCustomizacionB,
  rotarObjeto3D
} from './Funciones/customizacion.js'
import {
  clickEtapa3,
  tecladoEtapa1,
  tecladoEtapa2,
  contemplacion,
  vistaTotalModelos,
  recargarVistaCurada
} from './Funciones/espacio3D.js'

///////////////////////////// Variables

// Estados: Aviso -> CustomizaciónA -> CustomizaciónB -> Etapa 1 -> Etapa2 -> Etapa 3 -> Etapa 4 -> Contemplación
var estado = "aviso";

var mundo;

var raycaster, mouse //Interacción con mouse
var orientacion = "frente";
var mov = 0;
var rota = false;

var usuario, modeloUsuario;
var red = [];
var indicesSimilitud = [];
var modelosRed;

var colision = -1;
var lastKey = -1;

var seguir = false;
var texto, nom;
var btn;

/// movimiento
let controls;

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;

let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const vertex = new THREE.Vector3();
const color = new THREE.Color();


/// instrucciones
var cargo = true;
var play = true;

///////////////////////////////////////////// Inicializar Estados
export function customizaciónA() {
  estado = "customizaciónA";
  // Elimino si habia otras
  while (mundo.escena.children.length > 1) {
    if (mundo.escena.children[1].children.length > 1) {
      mundo.escena.children[1].children[1].stop();
      mundo.escena.children[1].remove(mundo.escena.children[1].children[1])
    }
    mundo.escena.remove(mundo.escena.children[1]);
    mundo.escena.remove(mundo.escena.children[1]);
  }

  let inputVal = document.getElementById("nombre");
  if (inputVal != null) {
    document.body.removeChild(inputVal);
  }

  crearFormasInicio(mundo.escena);
}

export function customizaciónB(seleccion) {
  estado = "customizaciónB";

  // Guardo forma elegida
  if (seleccion.position.x < 0) {
    usuario.forma = "cubo";
  } else {
    usuario.forma = "cono";
  }

  // Eliminar objetos 3D no deseados
  for (var i = 1; i < mundo.escena.children.length; i++) {
    if (mundo.escena.children[i] != seleccion) {
      mundo.escena.remove(mundo.escena.children[i]);
    }
  }

  // Cambiar visualización
  seleccion.position.x = 0;
  seleccion.scale.set(1.5, 1.5, 1.5);

  // Botones
  mundo.escena.add(crearBotones(mundo.listener));

  crearTexto(mundo.escena, "<", -2.2, 0.85, 0)

  btn = document.getElementById("bContinuar");
  btn.value = "Comenzar";
  btn.style.color = "grey";

  nom = document.createElement("p");
  nom.setAttribute("id", "nombre");
  nom.style.color = "white";
  nom.innerText = "escriba su nombre";
  document.body.appendChild(nom);
}

export function etapa1() {
  // Instrucciones
  instrucciones(" Mover: WASD o Flechas \n\n ");
  mundo.listener.setMasterVolume(0);

  //
  let inputVal = document.getElementById("nombre");
  usuario.nombre = inputVal.innerText;
  usuario.crearID();
  document.body.removeChild(inputVal);

  // Elimino si habia otras
  estado = "etapa1";
  while (mundo.escena.children.length > 1) {
    mundo.escena.remove(mundo.escena.children[1]);
    mundo.escena.remove(mundo.escena.children[1]);
  }
  mundo.crearFondo();

  // modelo3D usuario
  modeloUsuario = crearFormaUsuario(mundo.escena, mundo.listener, usuario);

  // red de usuarios pasados
  modelosRed = new THREE.Object3D;

  //////////////// Pruebas
  //figuraPrueba(red);
  figurasAleatorias(red);
  //agregarModelos(mundo.listener, red, modelosRed)
  agregarModelosCurado(mundo.listener, red, modelosRed, indicesSimilitud, usuario)

  mundo.escena.add(modelosRed);

  /////////// tiempo
  usuario.tiempo = usuario.tiempo + mundo.reloj.getElapsedTime();
  console.log("Tiempo en la obra", usuario.tiempo);
  mundo.reloj.start();
  seguir = false;
  btn.removeEventListener("click", etapa1);
  btn.value = "";
  btn.style.color = "white";

  //////////////////////////////////////// CAMARA
  mundo.camara.position.y = 2;
  mundo.camara.lookAt({
    x: usuario.x,
    y: usuario.y,
    z: usuario.z
  });

  mov = Math.PI;

  //
  mundo.bloomPass.strength = 4;
}

function etapa2() {
  instrucciones(" Mover: WASD o Flechas \n Rotar: Click & Drag \n\n ");
  mundo.listener.setMasterVolume(0);

  estado = "etapa2";
  console.log("pasando a vista total")
  vistaTotalModelos(mundo.listener, red, modelosRed, usuario, indicesSimilitud);
  mundo.escena.fog.near = 20;
  mundo.bloomPass.strength -= 0.9;

  // Tiempo
  usuario.tiempo = usuario.tiempo + mundo.reloj.getElapsedTime();
  console.log("Tiempo en la obra", usuario.tiempo);
  mundo.reloj.start();

  // Botón
  btn.value = " ";
  btn.removeEventListener("click", etapa2);
  seguir = false;
}

function etapa3() {
  estado = "etapa3";
  mundo.bloomPass.strength -= 0.9;

  instrucciones(" Mover: WASD o Flechas \n Rotar: Click & Drag \n Ver: Click \n\n ");
  cargo = true;

  // Tiempo
  usuario.tiempo = usuario.tiempo + mundo.reloj.getElapsedTime();
  console.log("Tiempo en la obra", usuario.tiempo);
  mundo.reloj.start();

  // Botón
  btn.value = " ";
  btn.removeEventListener("click", etapa3);
  seguir = false;

  // Texto
  texto.style.top = '45%';
  texto.style.left = '60%';
}

function etapa4() {
  borrarDatos();
  instrucciones(" Mover: WASD o Flechas \n Rotar: Click & Drag \n Inclinación: Ruedita \n Ver: Click \n\n ");
  cargo = true;

  estado = "etapa4";
  mundo.bloomPass.strength -= 0.9;

  // Tiempo
  usuario.tiempo = usuario.tiempo + mundo.reloj.getElapsedTime();
  console.log("Tiempo en la obra", usuario.tiempo);
  mundo.reloj.start();

  // Botón
  btn.value = " ";
  btn.removeEventListener("click", etapa4);
  seguir = false;

  mundo.escena.fog = null;

  //Código
  verCodigo(usuario.x,usuario.y,usuario.z)

  //Scroll
  document.addEventListener('wheel', function(event){
     event.preventDefault();
     if (event.deltaY > 0 && mundo.camara.position.y > -0.9){
       mundo.camara.position.y -= 0.1;
     } else if (event.deltaY < 0 && mundo.camara.position.y < 1.5) {
       mundo.camara.position.y += 0.1;
     }
     mundo.camara.lookAt(modeloUsuario.position);
  });
}

///////////////////////////////////////////// Estas idealmente se irian de aca

function verCodigo(x,y,z) {
  const loader = new THREE.TextureLoader();
  const texture = loader.load('../data/imagenes/cod02.png');

  const planeGeo = new THREE.PlaneGeometry(300, 420);
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  mesh.position.set(0,150,-190);
  mesh.lookAt(x,y,z);
  mundo.escena.add(mesh);
}

function instrucciones(texto) {
  const instructions = document.getElementById("instructions");
  const blocker = document.getElementById("blocker");
  instructions.style.display = 'flex';
  const t = document.getElementById("tins");
  t.style.top = "30%";
  t.innerText = texto;
  t.style.textAlign = "center";

  blocker.style.display = '';

  if (estado != "etapa3") {
    const p = document.getElementById("play");
    p.innerText = " \n\n\n Preparando espacio";
    cargo = false;
  }
  play = false;
}

function calcularCaraB() {
  const v = [Math.abs(0 - mov), Math.abs(Math.PI - mov), Math.abs(Math.PI * 2 - mov), Math.abs(Math.PI * 3 - mov)];
  const index = v.indexOf(Math.min(...v))

  if (index == 0) {
    orientacion = "izquierda"
    mov = 0;
  } else if (index == 1) {
    orientacion = "frente"
    mov = Math.PI;
  } else if (index == 2) {
    orientacion = "derecha"
    mov = Math.PI * 2;
  } else {
    orientacion = "espalda"
    mov = Math.PI * 3;
  }
}

function botonSeguir(reloj) {
  if (play && reloj.getElapsedTime() > 1) {
    seguir = !seguir;
    if (seguir) {

      btn = document.getElementById("bContinuar");
      btn.value = "Continuar";
      if (estado == "etapa1") {
        btn.addEventListener("click", etapa2);
      } else if (estado == "etapa2") {
        btn.addEventListener("click", etapa3);
      } else if (estado == "etapa3") {
        btn.addEventListener("click", etapa4);
      } else if (estado == "etapa4") {
        btn.addEventListener("click", function() {
          estado = "contemplacion";
          btn.remove();
          borrarDatos();
        });
        btn.value = "Terminar";
      }

    } else {
      seguir = true;
    }
  }
}

function borde(x, z) {
  if (x > 195 || x < -195) {
    x = 0;
  }
  if (z > 195 || x < -195) {
    z = 0;
  }
  return x, z;
}

function mostrarDatos(vel) {
  const te = document.getElementById("dato");
  if (te != null && te.style.opacity > 0) {
    te.style.opacity -= vel;
  } else if (te != null && te.style.opacity == 0) {
    te.remove();
  }
}

function borrarDatos() {
  var te = document.getElementById("dato");
  while (te != null) {
    te.remove();
    te = document.getElementById("dato");
  }
}
///// ThreeJS

function inicializar() {
  ///// texto
  texto = document.createElement('p');
  document.body.append(texto);

  // Mundo
  mundo = new Mundo();
  mundo.crearFondoCustomizacion();

  // usuario
  usuario = new Figura();

  // Interacción
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  // Interacción click y teclado
  document.addEventListener('mousedown', function(event) {
    if (play) {
      event.preventDefault();
      // mouse
      mouse.x = (event.clientX / mundo.renderizador.domElement.clientWidth) * 2 - 1;
      mouse.y = -(event.clientY / mundo.renderizador.domElement.clientHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, mundo.camara);

      if (estado == "customizaciónA") {
        clickCustomizacionA(mundo.escena.children, raycaster, usuario, mundo.listener, mundo.escena, estado);
      } else if (estado == "customizaciónB") {
        clickCustomizacionB(mundo.escena.children, raycaster, usuario, mundo.listener);

      } else if (estado == "etapa2") {
        rota = true;
      } else if (estado == "etapa3" || estado == "etapa4") {
        clickEtapa3(modelosRed.children, red, raycaster, mouse, indicesSimilitud);
        rota = true;
      }
    }
  }, false); // Mouse
  var oldX, oldY = 0;
  document.onpointermove = function() {
    if ((estado == "etapa2" || estado == "etapa3") && rota) {
      if (mouse.x < 0 && mov < Math.PI * 3) {
        mov += 0.1;
      } else if (mouse.x > 0 && mov > 0) {
        mov -= 0.1;
      }
    } else if (estado == "etapa4" && rota) {
      if (mouse.x < 0) {
        mov += 0.25;
      } else if (mouse.x > 0) {
        mov -= 0.25;
      }
    }
  };
  document.onpointerup = function() {
    if (estado == "etapa2" || estado == "etapa3") {
      rota = false;
      calcularCaraB();
    } else if (estado == "etapa4") {
      rota = false;
    }
  };
  document.onkeydown = function(e) {
    if (play) {
      if (estado == "customizaciónB") {
        nom.innerText = tecladoCustomizacionB(nom.innerText);
      }
      if (estado == "etapa1") {
        tecladoEtapa1(e, usuario);
      } else if (estado == "etapa2" || estado == "etapa3") {
        tecladoEtapa2(orientacion, e, usuario, colision, lastKey)
      }
    }
  };

  // Resize
  window.addEventListener('resize', onWindowResize);
  window.addEventListener("beforeunload", function(e) {

    if (estado != "contemplacion") {
      var confirmationMessage = 'La experiencia aun no termina';

      (e || window.event).returnValue = confirmationMessage; //Gecko + IE
      return confirmationMessage; //Gecko + Webkit, Safari, Chrome etc.
    }
  });

  // Movimiento cámara
  controls = new PointerLockControls(mundo.camara, document.body);
  mundo.escena.add(controls.getObject());

  // Movimiento teclas
  const onKeyDown = function(event) {
    if (play) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
      }
    }
  };
  const onKeyUp = function(event) {
    if (play) {
      switch (event.code) {

        case 'ArrowUp':
        case 'KeyW':
          moveForward = false;
          break;

        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = false;
          break;

        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;

        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;

      }
    }
  };
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  // Instrucciones
  const ins = document.getElementById("instructions");
  const bl = document.getElementById("blocker");
  bl.addEventListener('click', function() {
    if (cargo) {
      play = true;
      ins.style.display = 'none';
      bl.style.display = 'none';

      if (estado == "aviso") {
        customizaciónA();
      }
    }
  });

}

function animar() {
  requestAnimationFrame(animar);

  if (estado == "aviso") {
    // Aca iria imagen o algo
    texto.innerText = "Último upadte: 01/07 18pm ";
  } else if (estado == "customizaciónA") {
    rotarObjeto3D(mundo.escena.children[1]);
    rotarObjeto3D(mundo.escena.children[2]);
    texto.innerText = " ";
  } else if (estado == "customizaciónB") {
    rotarObjeto3D(mundo.escena.children[1]);
    texto.innerText = " ";

    if (usuario.color != '#FF0000' && usuario.sonido != '../data/sonidos/1/Sonido (1).wav' && nom.innerText != "escriba su nombre" && nom.innerText.length > 0) {
      // Botón para siguiente etapa
      seguir = !seguir;
      if (seguir) {
        btn.style.color = "white";
        btn.addEventListener("click", etapa1);
      } else {
        seguir = true;
      }
    }

  } else if (estado == "etapa1" || estado == "etapa2" || estado == "etapa3") {
    modeloUsuario.position.set(usuario.x, usuario.y, usuario.z);
    usuario.limite(195);
    usuario.calcularConexiones(red);
    moveteSiNosParecemos(modelosRed.children, indicesSimilitud);

    mundo.camara.position.x = usuario.x + 3.5 * Math.cos(0.5 * mov);
    mundo.camara.position.z = usuario.z + 3.5 * Math.sin(0.5 * mov);
    mundo.camara.lookAt(modeloUsuario.position);

    botonSeguir(mundo.reloj);

    if (estado == "etapa3") {
      if (play) {
        texto.innerText = usuario.texto(mundo.reloj.getElapsedTime(), orientacion);
      } else {
        texto.innerText = "";
      }
      mostrarDatos(0.02);
    } else {
      texto.innerText = " ";

    }

  } else if (estado == "etapa4") {
    usuario.calcularConexiones(red);
    moveteSiNosParecemos(modelosRed.children, indicesSimilitud);
    botonSeguir(mundo.reloj);

    if (play) {
      texto.innerText = usuario.texto(mundo.reloj.getElapsedTime(), "libre");
    } else {
      texto.innerText = "";
    }
    mostrarDatos(0.008);

    /// movimiento
    const time = performance.now();
    const delta = (time - prevTime) / 1000;

    if (rota) {
      mundo.camara.position.x = usuario.x + 3.5 * Math.cos(0.5 * mov);
      mundo.camara.position.z = usuario.z + 3.5 * Math.sin(0.5 * mov);
      mundo.camara.lookAt(modeloUsuario.position);
    } else {
      velocity.x -= velocity.x * 8.0 * delta;
      velocity.z -= velocity.z * 8.0 * delta;

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize(); // this ensures consistent movements in all directions

      if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);

      var angulo = Math.atan2(mundo.camara.getWorldDirection().z, mundo.camara.getWorldDirection().x)
      usuario.x = mundo.camara.position.x + 3.5 * Math.cos(angulo);
      usuario.z = mundo.camara.position.z + 3.5 * Math.sin(angulo);

      prevTime = time;
    }

    if ( usuario.limite(200) ){
      mundo.camara.position.x = usuario.x + 3.5 * Math.cos(0.5 * mov);
      mundo.camara.position.z = usuario.z + 3.5 * Math.sin(0.5 * mov);
    }

    modeloUsuario.position.set(usuario.x, usuario.y, usuario.z);

  } else if (estado == "contemplacion") {
    mov += 0.01;
    mundo.camara.position.x = usuario.x + 5 * Math.cos(0.5 * mov);
    mundo.camara.position.z = usuario.z + 5 * Math.sin(0.5 * mov);
    mundo.camara.lookAt(modeloUsuario.position);
    texto.innerText = " ";
  } // etapa1

  //console.log(mundo.reloj.getElapsedTime())
  ////////
  THREE.DefaultLoadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {

    console.log('Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.');

  };
  THREE.DefaultLoadingManager.onLoad = function() {
    console.log('Loading Complete!');
    cargo = true;
    const bl = document.getElementById("blocker");
    const ins = document.getElementById("play");
    ins.innerText = ("\n\n\n Hace click para empezar");

    for (let i = 0; i <= 1; i += 0.001) {
      mundo.listener.setMasterVolume(i);
    }
  };

  ////////
  mundo.renderizar();
}

function onWindowResize() {

  mundo.camara.aspect = window.innerWidth / window.innerHeight;
  mundo.camara.updateProjectionMatrix();

  mundo.renderizador.setSize(window.innerWidth, window.innerHeight);

}

///// Programa Principal
if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  // true for mobile device
  console.log("celular");
  texto = document.createElement('p');
  document.body.append(texto);
  texto.innerText = "Por favor use una computadora para ver esta página";
  document.getElementById("play").innerText = "";

} else {
  // false for not mobile device
  console.log("web");
  inicializar();
  animar();
}
